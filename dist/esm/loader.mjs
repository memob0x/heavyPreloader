function _classPrivateFieldGet(receiver,privateMap){var descriptor=privateMap.get(receiver);if(!descriptor){throw new TypeError("attempted to get private field on non-instance");}if(descriptor.get){return descriptor.get.call(receiver);}return descriptor.value;}import{getURL}from"./loader.utils.mjs";import Fetch from"./loader.fetch.mjs";import Load from"./loader.load.mjs";var _fetch=new WeakMap();var _load=new WeakMap();export default class Loader{constructor(){_fetch.set(this,{writable:true,value:new Fetch()});_load.set(this,{writable:true,value:new Load()});}async fetch(resource,options){if(Array.isArray(resource)){return await resource.map(a=>this.fetch(a,options));}if(typeof resource==="string"){return await this.fetch(getURL(resource),options);}if(resource instanceof URL){return await _classPrivateFieldGet(this,_fetch).fetch(resource.href,options);}throw new TypeError(`Invalid argment of type ${typeof resource} passed to Loader class "fetch" method.`);}async load(resource,options){if(Array.isArray(resource)){const isArrayOpts=Array.isArray(options);return await resource.map((a,i)=>this.load(a,isArrayOpts?options[i]:options));}const blob=resource instanceof Blob?resource:await this.fetch(resource,options);return await _classPrivateFieldGet(this,_load).load(blob,options);}register(type,loader){return _classPrivateFieldGet(this,_load).register(type,loader);}}