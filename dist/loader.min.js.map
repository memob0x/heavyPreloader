{"version":3,"sources":["src/loader.utils.mjs","src/loader.worker.mjs","src/loader.fetch.mjs","src/loader.mjs"],"names":["global","factory","exports","module","define","amd","self","Loader","this","getURL","href","URL","a","document","createElement","work","onmessage","async","event","data","message","response","fetch","options","blob","status","statusText","e","postMessage","worker","getOrCreateWorker","TypeError","url","createObjectURL","Blob","toString","type","Worker","revokeObjectURL","createWorker","cache","fetch$1","Promise","resolve","reject","addEventListener","Error","[object Object]","cors","arg","Array","isArray","map"],"mappings":"CAAC,SAAUA,EAAQC,GACI,iBAAZC,SAA0C,oBAAXC,OAAyBA,OAAOD,QAAUD,IAC9D,mBAAXG,QAAyBA,OAAOC,IAAMD,OAAO,SAAUH,IAC7DD,EAASA,GAAUM,MAAaC,OAASN,IAH9C,CAIEO,KAAM,WAAe,aAEnB,MAAMC,EAAUC,GACZ,IAAIC,IACA,CAAEC,IACEA,EAAEF,KAAOA,EAEFE,GAHX,CAIGC,SAASC,cAAc,OAuB5BC,EAAO,KACTC,UAAYC,OAAOC,IACf,MAAMC,EAAOD,EAAMC,KAEnB,IAAIC,EACJ,IACI,MAAMC,QAAiBC,MAAMH,EAAKT,KAAMS,EAAKI,SACvCC,QAAaH,EAASG,OAE5BJ,EAAU,CACNK,OAAQJ,EAASI,OACjBC,WAAYL,EAASK,WACrBF,KAAMA,GAEZ,MAAOG,GACLP,EAAU,CACNK,OAAQ,EACRC,WAAYC,GAIpBP,EAAQV,KAAOS,EAAKT,KACpBkB,YAAYR,MAIpB,IAAIS,EAAS,KAEb,MAAMC,EAAoB,IACtBD,IAAmBA,EAjDF,CAACd,IAClB,GAAoB,mBAATA,EACP,MAAM,IAAIgB,4CAC4BhB,8DAI1C,MAAMiB,EAAMrB,IAAIsB,gBACZ,IAAIC,KAAK,CAAC,IAAKnB,EAAKoB,WAAY,OAAQ,CACpCC,KAAM,4BAIRP,EAAS,IAAIQ,OAAOL,GAI1B,OAFArB,IAAI2B,gBAAgBN,GAEbH,GAgCqBU,CAAaxB,IAEvCyB,EAAQ,GAEd,IAAIC,EAAUxB,MAAOP,EAAMa,EAAU,KAC7Bb,KAAQ8B,QACKA,EAAM9B,GAGf8B,EAAM9B,GAAQ,IAAIgC,QAAQ,CAACC,EAASC,KACxC,MAAMf,EAASC,IAEfD,EAAOD,YAAY,CACflB,KAAMA,EACNa,QAASA,EAAQD,QAGrBO,EAAOgB,iBAAiB,UAAY3B,IAChC,MAAMC,EAAOD,EAAMC,KAEfA,EAAKT,OAASA,IAIE,MAAhBS,EAAKM,OAMTmB,EAAO,IAAIE,SAAS3B,EAAKO,kBAAkBP,EAAKT,mBAL5CiC,EAAQxB,EAAKK,WAoC7B,OA1BA,MACIuB,YAAYxB,GACRf,KAAKe,QAAU,CAAOD,MAAO,CAAE0B,KAAM,cAAkBzB,GAG3DwB,MAAME,GACF,OAAIC,MAAMC,QAAQF,GACPA,EAAIG,IAAKxC,GAAMJ,KAAKc,MAAMV,IAGlB,iBAARqC,EACAzC,KAAKc,MAAMb,EAAOwC,IAGzBA,aAAetC,IACR8B,EAAQQ,EAAIvC,KAAMF,KAAKe,SAG3BmB,QAAQE,OACX,IAAIb,4CACkCkB","sourcesContent":["/**\n *\n * @private\n * @static\n * @param {String} href\n * @returns {URL}\n */\nexport const getURL = (href) =>\n    new URL(\n        ((a) => {\n            a.href = href;\n\n            return a;\n        })(document.createElement(\"a\"))\n    );\n\n/**\n *\n * @private\n * @static\n * @param {Function} work\n * @returns {Worker}\n */\nexport const createWorker = (work) => {\n    if (typeof work !== \"function\") {\n        throw new TypeError(\n            `Invalid argment of type ${typeof work} passed to Loader class internal \"createWorker\" function.`\n        );\n    }\n\n    const url = URL.createObjectURL(\n        new Blob([\"(\", work.toString(), \")()\"], {\n            type: \"application/javascript\",\n        })\n    );\n\n    const worker = new Worker(url);\n\n    URL.revokeObjectURL(url);\n\n    return worker;\n};\n","import { createWorker } from \"./loader.utils.mjs\";\n\n/**\n *\n * @private\n * @static\n */\nexport const work = () => {\n    onmessage = async (event) => {\n        const data = event.data;\n\n        // ...\n        let message;\n        try {\n            const response = await fetch(data.href, data.options);\n            const blob = await response.blob();\n\n            message = {\n                status: response.status,\n                statusText: response.statusText,\n                blob: blob,\n            };\n        } catch (e) {\n            message = {\n                status: 0,\n                statusText: e,\n            };\n        }\n\n        // ...\n        message.href = data.href;\n        postMessage(message);\n    };\n};\n\n// ...\nlet worker = null;\n\n/**\n *\n * @private\n */\nexport const getOrCreateWorker = () =>\n    worker ? worker : (worker = createWorker(work));\n\n/**\n *\n * @private\n */\nexport const possiblyTerminateWorker = () => {\n    // TODO: check if no longer in use\n    // worker.terminate();\n    // worker = null;\n};\n","import { getOrCreateWorker } from \"./loader.worker.mjs\";\n\n// ...\nconst cache = {};\n\n/**\n *\n * @private\n * @param {String} href\n * @param {Object} options\n */\nexport default async (href, options = {}) => {\n    // ...\n    if (href in cache) {\n        return await cache[href];\n    }\n\n    // ...\n    return (cache[href] = new Promise((resolve, reject) => {\n        const worker = getOrCreateWorker();\n\n        // ...\n        worker.postMessage({\n            href: href,\n            options: options.fetch,\n        });\n\n        // ...\n        worker.addEventListener(\"message\", (event) => {\n            const data = event.data;\n\n            // ...\n            if (data.href !== href) {\n                return;\n            }\n\n            // ...\n            if (data.status === 200) {\n                resolve(data.blob);\n\n                return;\n            }\n\n            // ...\n            reject(new Error(`${data.statusText} for ${data.href} resource.`));\n        });\n    }));\n};\n","import { getURL } from \"./loader.utils.mjs\";\nimport fetch from \"./loader.fetch.mjs\";\n\nexport default class Loader {\n    /**\n     *\n     * @param {Object} options\n     */\n    constructor(options) {\n        this.options = { ...{ fetch: { cors: \"no-cors\" } }, ...options };\n    }\n\n    /**\n     *\n     * @param {Array.<String>|Array.<URL>|String|URL} arg\n     * @returns {Array.<Promise>|Promise}\n     */\n    fetch(arg) {\n        // ...\n        if (Array.isArray(arg)) {\n            return arg.map((a) => this.fetch(a));\n        }\n\n        // ...\n        if (typeof arg === \"string\") {\n            return this.fetch(getURL(arg));\n        }\n\n        // ...\n        if (arg instanceof URL) {\n            return fetch(arg.href, this.options);\n        }\n\n        // ...\n        return Promise.reject(\n            new TypeError(\n                `Invalid argment of type ${typeof arg} passed to Loader class \"fetch\" method.`\n            )\n        );\n    }\n}\n"],"file":"loader.min.js"}