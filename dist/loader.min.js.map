{"version":3,"sources":["src/loader.worker.mjs","src/loader.fetch.mjs","src/loader.load.css.mjs","src/loader.load.html.mjs","src/loader.load.image.mjs","src/loader.load.javascript.mjs","src/loader.load.mjs","src/loader.mjs"],"names":["global","factory","exports","module","define","amd","self","Loader","this","body","onmessage","async","event","response","fetch","data","href","options","blob","status","statusText","e","postMessage","lworker","requests","cache","lfetch","Promise","resolve","reject","worker","url","URL","createObjectURL","Blob","toString","type","Worker","revokeObjectURL","get","addEventListener","terminate","Error","lload","image","element","HTMLImageElement","Image","promise","onload","onerror","src","result","reader","FileReader","buffer","srcElement","readAsText","filter","length","DOMParser","parseFromString","querySelectorAll","map","x","outerHTML","reduce","y","HTMLElement","innerHTML","html","document","sheet","CSSStyleSheet","replace","adoptedStyleSheets","css","import","javascript","TypeError","[object Object]","resource","Array","isArray","a","createElement","isArrayOpts","i","load"],"mappings":"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","sourcesContent":["/**\n *\n * @private\n * @static\n */\nconst body = () =>\n    (onmessage = async (event) => {\n        //\n        try {\n            const response = await fetch(event.data.href, event.data.options);\n            const blob = await response.blob();\n\n            event.data.status = response.status;\n            event.data.statusText = response.statusText;\n            event.data.blob = blob;\n        } catch (e) {\n            event.data.statusText = e;\n        }\n\n        // ...\n        postMessage(event.data);\n    });\n\n// ...\nlet lworker = null;\nlet requests = 0;\n\n/**\n *\n * @private\n */\nexport const get = () => {\n    // ...\n    requests++;\n\n    // ...\n    if (lworker) {\n        return lworker;\n    }\n\n    // ...\n    const url = URL.createObjectURL(\n        new Blob([\"(\", body.toString(), \")()\"], {\n            type: \"application/javascript\",\n        })\n    );\n\n    // ...\n    lworker = new Worker(url);\n\n    // ...\n    URL.revokeObjectURL(url);\n\n    //\n    return lworker;\n};\n\n/**\n *\n * @private\n */\nexport const terminate = () => {\n    //\n    requests--;\n\n    //\n    if (requests <= 0) {\n        lworker.terminate();\n\n        lworker = null;\n    }\n};\n","import * as lworker from \"./loader.worker.mjs\";\n\n// ...\nconst cache = {};\n\n/**\n * Fetches a resource url in the secondary thread and retrieves it as a blob\n * @private\n * @param {String} href The resource url to be fetched\n * @param {Object} options The fetch options object\n * @returns {Promise} The fetch promise\n */\nexport default async (href, options) => {\n    // ...\n    options = {\n        ...{\n            cache: true,\n            fetch: {},\n        },\n        ...options,\n    };\n\n    // ...\n    if (options.cache === true && href in cache) {\n        return await cache[href];\n    }\n\n    // ...\n    return (cache[href] = new Promise((resolve, reject) => {\n        //\n        const worker = lworker.get();\n\n        // ...\n        worker.postMessage({\n            href: href,\n            options: options.fetch,\n        });\n\n        // ...\n        // TODO: possibly use messageerror for reject?\n        worker.addEventListener(\"message\", (event) => {\n            const data = event.data;\n\n            // ...\n            if (data.href !== href) {\n                return;\n            }\n\n            //\n            lworker.terminate();\n\n            // ...\n            if (data.status === 200) {\n                resolve(data.blob);\n\n                return;\n            }\n\n            // ...\n            reject(new Error(`${data.statusText} for ${data.href} resource.`));\n        });\n    }));\n};\n","export default async (blob, options) => {\n    //\n    options = { ...{ element: document }, options };\n\n    //\n    const url = URL.createObjectURL(blob);\n\n    //\n    const sheet = new CSSStyleSheet();\n\n    //\n    await sheet.replace(`@import url(\"${url}\")`);\n\n    //\n    URL.revokeObjectURL(url);\n\n    //\n    if (\n        typeof options.element === \"object\" &&\n        \"adoptedStyleSheets\" in options.element\n    ) {\n        options.element.adoptedStyleSheets = [\n            ...options.element.adoptedStyleSheets,\n            sheet,\n        ];\n    }\n\n    //\n    return sheet;\n};\n","export default async (blob, options) => {\n    //\n    const reader = new FileReader();\n\n    //\n    const promise = new Promise((resolve) =>\n        reader.addEventListener(\"loadend\", (buffer) =>\n            resolve(buffer.srcElement.result)\n        )\n    );\n\n    //\n    reader.readAsText(blob);\n\n    //\n    let result = await promise;\n\n    //\n    if (typeof options.filter === \"string\" && options.filter.length) {\n        //\n        result = new DOMParser().parseFromString(result, \"text/html\").body;\n        //\n        result = [...result.querySelectorAll(options.filter)];\n        //\n        result = result.map((x) => x.outerHTML).reduce((x, y) => x + y);\n    }\n\n    //\n    if (options.element && options.element instanceof HTMLElement) {\n        options.element.innerHTML = result;\n    }\n\n    //\n    return promise;\n};\n","export default async (blob, options) => {\n    //\n    const image =\n        options.element instanceof HTMLImageElement\n            ? options.element\n            : new Image();\n\n    //\n    const url = URL.createObjectURL(blob);\n\n    //\n    const promise = new Promise((resolve, reject) => {\n        image.onload = resolve;\n        image.onerror = reject;\n    });\n\n    //\n    image.src = url;\n\n    //\n    const result = await promise;\n\n    //\n    URL.revokeObjectURL(url);\n\n    //\n    return result;\n};\n","export default async (blob) => {\n    //\n    const url = URL.createObjectURL(blob);\n\n    //\n    const result = await import(url);\n\n    //\n    URL.revokeObjectURL(url);\n\n    //\n    return result;\n};\n","import css from \"./loader.load.css.mjs\";\nimport html from \"./loader.load.html.mjs\";\nimport image from \"./loader.load.image.mjs\";\nimport javascript from \"./loader.load.javascript.mjs\";\n\n/**\n * Loads a resource, which usually consists in attaching it to an existent DOM element\n * @private\n * @param {Blob} blob The resource to be loaded in Blob form\n * @param {Object} options The resource load options\n * @returns {Promise} The resource load in promise form\n */\nexport default async (blob, options) => {\n    //...\n    // TODO: get all major mimetypes\n    switch (blob.type) {\n        //...\n        case \"image/png\":\n        case \"image/jpeg\":\n            return await image(blob, options);\n\n        //...\n        case \"text/html\":\n            return await html(blob, options);\n\n        //...\n        case \"text/css\":\n            return await css(blob, options);\n\n        //...\n        case \"text/javascript\":\n            return await javascript(blob);\n    }\n\n    // ...\n    throw new TypeError(\n        `Invalid argment of type ${typeof blob} passed to Loader class \"fetch\" method.`\n    );\n};\n","import lfetch from \"./loader.fetch.mjs\";\nimport lload from \"./loader.load.mjs\";\n\nexport default class Loader {\n    constructor() {}\n\n    /**\n     * Fetches one or more resources url\n     * @param {Array.<String>|Array.<URL>|String|URL} resource The resource(s) url to be fetched in a separate thread\n     * @param {Object} options The fetch options object\n     * @returns {Array.<Promise>|Promise} The fetch promise(s)\n     */\n    async fetch(resource, options) {\n        // ...\n        if (Array.isArray(resource)) {\n            return await resource.map((a) => this.fetch(a, options));\n        }\n\n        // ...\n        if (typeof resource === \"string\") {\n            const a = document.createElement(\"a\");\n\n            a.href = resource;\n\n            return await this.fetch(new URL(a), options);\n        }\n\n        // ...\n        if (resource instanceof URL) {\n            return await lfetch(resource.href, options);\n        }\n\n        // ...\n        throw new TypeError(\n            `Invalid argment of type ${typeof resource} passed to Loader class \"fetch\" method.`\n        );\n    }\n\n    /**\n     * Loads one or more resources url considering the passed options object and the resource mime type to be loaded\n     * @param {Array.<String>|Array.<URL>|Array.<Blob>|String|URL|Blob} resource The resource(s) to be loaded\n     * @param {Object} options The loader type options\n     * @returns {Array.<Promise>|Promise} The load promise(s)\n     */\n    async load(resource, options) {\n        // ...\n        if (Array.isArray(resource)) {\n            const isArrayOpts = Array.isArray(options);\n\n            return await resource.map((a, i) =>\n                this.load(a, isArrayOpts ? options[i] : options)\n            );\n        }\n\n        // ...\n        const blob =\n            resource instanceof Blob\n                ? resource\n                : await this.fetch(resource, options);\n\n        // ...\n        return await lload(blob, options);\n    }\n}\n"],"file":"loader.min.js"}