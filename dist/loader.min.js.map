{"version":3,"sources":["src/loader.worker.mjs","src/loader.fetch.mjs","src/loader.load.css.mjs","src/loader.load.html.mjs","src/loader.load.image.mjs","src/loader.load.javascript.mjs","src/loader.load.mjs","src/loader.mjs"],"names":["global","factory","exports","module","define","amd","self","Loader","this","body","onmessage","async","event","response","fetch","data","href","options","blob","status","statusText","e","postMessage","lworker","requests","cache","lfetch","Promise","resolve","reject","worker","url","URL","createObjectURL","Blob","toString","type","Worker","revokeObjectURL","get","addEventListener","terminate","Error","lload","image","element","HTMLImageElement","Image","promise","onload","onerror","src","result","reader","FileReader","buffer","srcElement","readAsText","filter","length","DOMParser","parseFromString","querySelectorAll","map","x","outerHTML","reduce","y","HTMLElement","innerHTML","html","document","sheet","CSSStyleSheet","replace","adoptedStyleSheets","css","import","javascript","TypeError","[object Object]","cors","arg","Array","isArray","a","createElement","el","load"],"mappings":"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","sourcesContent":["/**\n *\n * @private\n * @static\n */\nconst body = () =>\n    (onmessage = async (event) => {\n        //\n        try {\n            const response = await fetch(event.data.href, event.data.options);\n            const blob = await response.blob();\n\n            event.data.status = response.status;\n            event.data.statusText = response.statusText;\n            event.data.blob = blob;\n        } catch (e) {\n            event.data.statusText = e;\n        }\n\n        // ...\n        postMessage(event.data);\n    });\n\n// ...\nlet lworker = null;\nlet requests = 0;\n\n/**\n *\n * @private\n */\nexport const get = () => {\n    // ...\n    requests++;\n\n    // ...\n    if (lworker) {\n        return lworker;\n    }\n\n    // ...\n    const url = URL.createObjectURL(\n        new Blob([\"(\", body.toString(), \")()\"], {\n            type: \"application/javascript\",\n        })\n    );\n\n    // ...\n    lworker = new Worker(url);\n\n    // ...\n    URL.revokeObjectURL(url);\n\n    //\n    return lworker;\n};\n\n/**\n *\n * @private\n */\nexport const terminate = () => {\n    //\n    requests--;\n\n    //\n    if (requests <= 0) {\n        lworker.terminate();\n\n        lworker = null;\n    }\n};\n","import * as lworker from \"./loader.worker.mjs\";\n\n// ...\nconst cache = {};\n\n/**\n *\n * @private\n * @param {String} href\n * @param {Object} options\n */\nexport default async (href, options = {}) => {\n    // ...\n    if (href in cache) {\n        return await cache[href];\n    }\n\n    // ...\n    return (cache[href] = new Promise((resolve, reject) => {\n        //\n        const worker = lworker.get();\n\n        // ...\n        worker.postMessage({\n            href: href,\n            options: options.fetch,\n        });\n\n        // ...\n        // TODO: possibly use messageerror for reject?\n        worker.addEventListener(\"message\", (event) => {\n            const data = event.data;\n\n            // ...\n            if (data.href !== href) {\n                return;\n            }\n\n            //\n            lworker.terminate();\n\n            // ...\n            if (data.status === 200) {\n                resolve(data.blob);\n\n                return;\n            }\n\n            // ...\n            reject(new Error(`${data.statusText} for ${data.href} resource.`));\n        });\n    }));\n};\n","export default async (blob, options) => {\n    //\n    options = { ...{ element: document }, options };\n\n    //\n    const url = URL.createObjectURL(blob);\n\n    //\n    const sheet = new CSSStyleSheet();\n\n    //\n    await sheet.replace(`@import url(\"${url}\")`);\n\n    //\n    URL.revokeObjectURL(url);\n\n    //\n    if (\"adoptedStyleSheets\" in options.element) {\n        options.element.adoptedStyleSheets = [\n            ...options.element.adoptedStyleSheets,\n            sheet,\n        ];\n    }\n\n    //\n    return sheet;\n};\n","export default async (blob, options) => {\n    //\n    const reader = new FileReader();\n\n    //\n    const promise = new Promise((resolve) =>\n        reader.addEventListener(\"loadend\", (buffer) =>\n            resolve(buffer.srcElement.result)\n        )\n    );\n\n    //\n    reader.readAsText(blob);\n\n    //\n    let result = await promise;\n\n    //\n    if (typeof options.filter === \"string\" && options.filter.length) {\n        //\n        result = new DOMParser().parseFromString(result, \"text/html\").body;\n        //\n        result = [...result.querySelectorAll(options.filter)];\n        //\n        result = result.map((x) => x.outerHTML).reduce((x, y) => x + y);\n    }\n\n    //\n    if (options.element && options.element instanceof HTMLElement) {\n        options.element.innerHTML = result;\n    }\n\n    //\n    return promise;\n};\n","export default async (blob, options) => {\n    //\n    const image =\n        options.element instanceof HTMLImageElement\n            ? options.element\n            : new Image();\n\n    //\n    const url = URL.createObjectURL(blob);\n\n    //\n    const promise = new Promise((resolve, reject) => {\n        image.onload = resolve;\n        image.onerror = reject;\n    });\n\n    //\n    image.src = url;\n\n    //\n    const result = await promise;\n\n    //\n    URL.revokeObjectURL(url);\n\n    //\n    return result;\n};\n","export default async (blob) => {\n    //\n    const url = URL.createObjectURL(blob);\n\n    //\n    const result = await import(url);\n\n    //\n    URL.revokeObjectURL(url);\n\n    //\n    return result;\n};\n","import css from \"./loader.load.css.mjs\";\nimport html from \"./loader.load.html.mjs\";\nimport image from \"./loader.load.image.mjs\";\nimport javascript from \"./loader.load.javascript.mjs\";\n\n/**\n *\n * @param {Blob} blob\n * @param {Object} options\n */\nexport default async (blob, options) => {\n    //...\n    switch (blob.type) {\n        //...\n        case \"image/png\":\n        case \"image/jpeg\":\n            return await image(blob, options);\n\n        //...\n        case \"text/html\":\n            return await html(blob, options);\n\n        //...\n        case \"text/css\":\n            return await css(blob, options);\n\n        //...\n        case \"text/javascript\":\n            return await javascript(blob);\n    }\n\n    // ...\n    throw new TypeError(\n        `Invalid argment of type ${typeof blob} passed to Loader class \"fetch\" method.`\n    );\n};\n","import lfetch from \"./loader.fetch.mjs\";\nimport lload from \"./loader.load.mjs\";\n\nexport default class Loader {\n    /**\n     *\n     * @param {Object} options\n     */\n    constructor(options) {\n        this.options = {\n            ...{ fetch: { cors: \"no-cors\" } },\n            ...options,\n        };\n    }\n\n    /**\n     *\n     * @param {Array.<String>|Array.<URL>|String|URL} arg\n     * @returns {Array.<Promise>|Promise}\n     */\n    async fetch(arg) {\n        // ...\n        if (Array.isArray(arg)) {\n            return await arg.map((a) => this.fetch(a));\n        }\n\n        // ...\n        if (typeof arg === \"string\") {\n            const a = document.createElement(\"a\");\n\n            a.href = arg;\n\n            return await this.fetch(new URL(a));\n        }\n\n        // ...\n        if (arg instanceof URL) {\n            return await lfetch(arg.href, this.options);\n        }\n\n        // ...\n        throw new TypeError(\n            `Invalid argment of type ${typeof arg} passed to Loader class \"fetch\" method.`\n        );\n    }\n\n    /**\n     *\n     * @param {Array.<String>|Array.<URL>|String|URL} arg\n     * @returns {Array.<Promise>|Promise}\n     */\n    async load(arg, el) {\n        // ...\n        if (Array.isArray(arg)) {\n            return await arg.map((a) => this.load(a, el));\n        }\n\n        // ...\n        const blob = await this.fetch(arg);\n\n        // ...\n        return await lload(blob, el);\n    }\n}\n"],"file":"loader.min.js"}